# 구현 설명서

## 1. 설계 구조 및 설계에 대한 설명

### 1.1 전체 아키텍처
- **마이크로서비스 아키텍처**: 각 도메인별로 독립적인 서비스로 분리
- **헥사고날 아키텍처**: 각 서비스 내부는 헥사고날 아키텍처로 구성
- **이벤트 기반 통신**: Kafka를 통한 비동기 이벤트 처리
- **동기 통신**: gRPC를 통한 서비스 간 동기 통신

### 1.2 서비스 구성
1. **Member Service**: 회원 관리 및 포인트 관리
2. **Product Service**: 상품 관리 및 재고 관리
3. **Order Service**: 주문 처리 및 조율
4. **Payment Service**: 결제 처리

### 1.3 헥사고날 아키텍처 구조
```
├── domain (도메인 모델)
├── application (유스케이스)
│   ├── port
│   │   ├── in (인바운드 포트)
│   │   └── out (아웃바운드 포트)
│   └── service (서비스 구현)
└── adapter
    ├── in (인바운드 어댑터)
    │   ├── web (REST API)
    │   └── grpc (gRPC 서버)
    └── out (아웃바운드 어댑터)
        ├── persistence (DB)
        ├── grpc (gRPC 클라이언트)
        └── kafka (이벤트 발행)
```

## 2. 설계 시 고민사항

### 2.1 동기 vs 비동기 통신
**고민**: 서비스 간 통신을 동기(REST/gRPC)로 할지, 비동기(Kafka)로 할지

**결정 및 이유**:
- 주문 생성 시 실시간 검증이 필요한 부분(회원 조회, 재고 확인)은 **gRPC**로 동기 통신
- 주문 완료 후 결제 처리는 **Kafka**를 통한 비동기 처리
- gRPC 선택 이유: REST보다 성능이 좋고, 타입 안정성 제공

### 2.2 트랜잭션 관리
**고민**: 분산 환경에서 데이터 일관성을 어떻게 보장할 것인가

**결정 및 이유**:
- Saga 패턴 적용 (Choreography 방식)
- 각 서비스는 자신의 트랜잭션만 관리
- 실패 시 보상 트랜잭션 처리 (현재는 TODO로 표시)
- 이유: 2PC보다 성능이 좋고, 서비스 간 결합도가 낮음

### 2.3 결제 방법 설계
**고민**: 다양한 결제 수단을 어떻게 확장 가능하게 설계할 것인가

**결정 및 이유**:
- Strategy 패턴 적용 (PaymentProcessor 인터페이스)
- 각 결제 수단별로 별도의 Processor 구현
- 새로운 결제 수단 추가 시 기존 코드 수정 없이 확장 가능

## 3. 개선 방향

### 3.1 단기 개선사항
1. **에러 처리 개선**
   - 글로벌 에러 핸들러 구현
   - 에러 코드 표준화
   - 상세한 에러 메시지 제공

2. **보안 강화**
   - JWT 기반 인증/인가 구현
   - API Rate Limiting
   - gRPC 통신 TLS 적용

3. **모니터링 추가**
   - Prometheus + Grafana 모니터링
   - ELK 스택 로그 수집
   - Distributed Tracing (Zipkin/Jaeger)

### 3.2 장기 개선사항
1. **데이터베이스 분리**
   - 현재 단일 DB → 서비스별 독립 DB
   - CQRS 패턴 적용 검토

2. **캐싱 전략**
   - Redis 도입으로 성능 개선
   - 상품 정보, 회원 정보 캐싱

3. **API Gateway 도입**
   - 인증, 라우팅, 로드밸런싱 중앙화
   - Circuit Breaker 패턴 적용

## 4. 제약사항

### 4.1 현재 구현의 제약사항
1. **트랜잭션 롤백 미구현**: 실패 시 보상 트랜잭션 로직 필요
2. **단일 데이터베이스**: 서비스 간 데이터베이스 의존성 존재
3. **동기 통신 의존**: 장애 전파 가능성
4. **보안 미적용**: 인증/인가 없음
5. **테스트 부족**: 통합 테스트, E2E 테스트 필요

### 4.2 성능 제약사항
- 현재 단일 인스턴스 기준 TPS: 약 100-200
- 데이터베이스 커넥션 풀: 10개
- 동시 처리 가능 주문: 약 50개

## 5. 트래픽 증가 시 개선 방향

### 5.1 10배 트래픽 (TPS 1,000-2,000)
1. **수평적 확장**
   - 각 서비스 인스턴스 3-5개로 증설
   - 로드밸런서 추가 (Nginx/HAProxy)

2. **데이터베이스 최적화**
   - Read Replica 추가
   - 커넥션 풀 크기 증가
   - 인덱스 최적화

3. **캐싱 적용**
   - Redis 캐시 레이어 추가
   - 자주 조회되는 데이터 캐싱

### 5.2 100배 트래픽 (TPS 10,000-20,000)
1. **아키텍처 개선**
   - CQRS 패턴 도입
   - Event Sourcing 적용
   - 데이터베이스 샤딩

2. **인프라 개선**
   - Kubernetes 기반 오케스트레이션
   - Auto-scaling 설정
   - Multi-region 배포

3. **비동기 처리 확대**
   - 주문 생성도 비동기 처리
   - Message Queue 다중화
   - Batch 처리 도입

4. **성능 최적화**
   - GraphQL 도입으로 Over-fetching 방지
   - gRPC 스트리밍 활용
   - 데이터베이스 파티셔닝

## 6. 기타 설명

### 6.1 기술 선택 이유
- **Kotlin**: Java보다 간결하고 Null Safety 제공
- **Spring Boot**: 빠른 개발과 풍부한 생태계
- **gRPC**: 높은 성능과 타입 안정성
- **Kafka**: 확장성과 내구성이 뛰어난 메시지 브로커
- **MySQL**: 안정적이고 널리 사용되는 RDBMS

### 6.2 향후 로드맵
1. **Phase 1**: 보안 및 모니터링 구축
2. **Phase 2**: 성능 최적화 및 캐싱
3. **Phase 3**: 마이크로서비스 고도화 (Service Mesh)
4. **Phase 4**: 글로벌 확장 대비

### 6.3 운영 고려사항
- Blue-Green 배포 전략
- 서비스별 독립적 배포 파이프라인
- 장애 격리 및 Circuit Breaker
- 정기적인 카오스 엔지니어링 테스트
